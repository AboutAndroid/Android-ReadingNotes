## RxJava

关于 RxJava 的异步

上游 -》发送事件 -》 下游接收事件 -》反馈给上游 -》上游继续发送事件／结束

- 上游可以发送无限个onNext, 下游也可以接收无限个onNext.

- 当上游发送了一个onComplete后, 上游onComplete之后的事件将会`继续`发送, 而下游收到onComplete事件之后将`不再继续`接收事件.

- 当上游发送了一个onError后, 上游onError之后的事件将`继续`发送, 而下游收到onError事件之后将`不再继续`接收事件.

- 上游可以不发送onComplete或onError.

- 最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然

- Disposable：当调用它的`dispose()`方法时, 它就会将上下游的两根管道切断, 从而导致下游收不到事件.

  注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件.

  ​

  当我们在主线程中去创建一个上游Observable来发送事件, 则这个上游默认就在主线程发送事件.

  当我们在主线程去创建一个下游Observer来接收事件, 则这个下游默认就在主线程中接收事件.

  简单的来说, `subscribeOn()` 指定的是上游发送事件的线程, `observeOn()` 指定的是下游接收事件的线程.

  多次指定上游的线程只有第一次指定的有效, 也就是说多次调用`subscribeOn()` 只有第一次的有效, 其余的会被忽略.

  多次指定下游的线程是可以的, 也就是说每调用一次`observeOn()` , 下游的线程就会切换一次.

  每调用一次`observeOn()` 线程便会切换一次, 因此如果我们有类似的需求时, 便可知道如何处理了.

  当上下游工作在`同一个线程`中时, 这时候是一个`同步`的订阅关系, 也就是说`上游`每发送一个事件`必须`等到`下游`接收处理完了以后才能接着发送下一个事件.

  在RxJava中, 已经内置了很多线程选项供我们选择, 例如有

  - Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作
  - Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作
  - Schedulers.newThread() 代表一个常规的新线程
  - AndroidSchedulers.mainThread() 代表Android的主线

  当上下游工作在`不同的线程`中时, 这时候是一个`异步`的订阅关系, 这个时候`上游`发送数据`不需要`等待`下游`接收, 为什么呢, 因为两个线程并不能直接进行通信, 因此上游发送的事件并不能直接到下游里去, 这个时候就需要一个田螺姑娘来帮助它们俩, 这个田螺姑娘就是我们刚才说的`水缸`! 上游把事件发送到水缸里去, 下游从水缸里取出事件来处理, 因此, 当上游发事件的速度太快, 下游取事件的速度太慢, 水缸就会迅速装满, 然后溢出来, 最后就OOM了.

  - ​

    ​

    ​

    ​